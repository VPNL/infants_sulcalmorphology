%% Script to compare the overlap between hand-drawn ROIs and 
% both UNC and FreeSurfer projected ROIs

% You cannot run this unless you (1) draw the ROI labels on the UNC template,
% (2) project the UNC labels onto each individual infant brain.


clear all; clc; close;
addpath(genpath('/oak/stanford/groups/kalanit/biac2/kgs/projects/vistasoft'))

% Subject list
subj = {
    'bb02_mri0_mask', 'bb11_mri0_mask', 'bb56_mri0_mask', 'bb22_mri0_mask',...
    'bb62_mri0_mask', 'bb07_mri0_mask', 'bb67_mri0_mask', 'bb28_mri0_mask',...
    'bb14_mri0_mask', 'bb37_mri0_mask'
};

roi_list = {'calcarine','insula','cingulate','pos','central','precentral','cos','sts',...
    'postcentral','sfs','ips','loc','ifs','ots', 'its'};

hemisphere = {'lh', 'rh'};  

% Initialize data structures
data_groundtruth = {};
data_UNC = {};
data_coarse = {};

i_gt = 0;  % Counter for groundtruth data
i_unc = 0; % Counter for UNC data
i_coarse = 0; % Counter for coarse data

%% Read manually drawn and UNC-projected labels

for s = 1:length(subj)
    label_dir = fullfile(['/oak/stanford/groups/kalanit/biac2/kgs/anatomy/freesurferRecon/babybrains/' subj{s} '/label/']);
    for h = 1:length(hemisphere)
        for r = 1:length(roi_list)
            % Read groundtruth
            fprintf('Reading manually drawn labels\n');
            gt_label_name = [hemisphere{h} '.' roi_list{r} '.groundtruth'];
            gt_data = read_label(subj{s}, gt_label_name);
            i_gt = i_gt + 1;
            data_groundtruth{i_gt} = gt_data(:, 1);
            
           
            
            % Read UNC
            fprintf('Reading UNC-projected labels\n');
            unc_label_name = [hemisphere{h} '.' roi_list{r} '.UNC.st'];
            unc_data = read_label(subj{s}, unc_label_name);
            i_unc = i_unc + 1;
            data_UNC{i_unc} = unc_data(:, 1);


            % Read fsaverage projected
            fprintf('Reading fsaverage-projected labels\n');
            coarse_label_name = [hemisphere{h} '.' roi_list{r} '.coarse.st'];
            coarse_data = read_label(subj{s}, coarse_label_name);
            if ~isempty(coarse_data)
                i_coarse = i_coarse + 1;
                data_coarse{i_coarse} = coarse_data(:, 1);
           
            end
        end
    end
end

%% Calculate Dice coefficients for UNC method

DC_UNC = zeros(1, length(data_UNC));

for l = 1:length(data_UNC)
    if isempty(data_groundtruth{l}) || isempty(data_UNC{l})
        DC_UNC(l) = NaN;
    else
        overlap_UNC = intersect(data_groundtruth{l}, data_UNC{l});
        DC_UNC(l) = 2 * (length(overlap_UNC)) / (length(data_groundtruth{l}) + length(data_UNC{l}));
    end
end

%% Calculate Dice coefficients for coarse method

DC_coarse = zeros(1, length(data_coarse));

for l = 1:length(data_coarse)
    if isempty(data_groundtruth{l}) || isempty(data_coarse{l})
        DC_coarse(l) = NaN;
    else
        overlap_coarse = intersect(data_groundtruth{l}, data_coarse{l});
        DC_coarse(l) = 2 * (length(overlap_coarse)) / (length(data_groundtruth{l}) + length(data_coarse{l}));
    end
end

%% Prepare data for 3-way ANOVA

% Initialize arrays to store data for ANOVA
dice_values = [];
hemisphere_factor = [];
roi_factor = [];
method_factor = [];
subject_factor = [];

% Organize data for ANOVA
for s = 1:length(subj)
    for h = 1:length(hemisphere)
        for r = 1:length(roi_list)
            idx = (s-1) * length(hemisphere) * length(roi_list) + ...
                  (h-1) * length(roi_list) + r;
            
            % Add UNC data point
            if ~isnan(DC_UNC(idx))
                dice_values = [dice_values; DC_UNC(idx)];
                hemisphere_factor = [hemisphere_factor; h]; 
                roi_factor = [roi_factor; r];
                method_factor = [method_factor; 1]; % 1=UNC
                subject_factor = [subject_factor; s];
            end
            
            % Add fsaverage data point
            if ~isnan(DC_coarse(idx))
                dice_values = [dice_values; DC_coarse(idx)];
                hemisphere_factor = [hemisphere_factor; h]; 
                roi_factor = [roi_factor; r];
                method_factor = [method_factor; 2]; % 2=fsaverage
                subject_factor = [subject_factor; s];
            end
        end
    end
end

%% Perform 3-way ANOVA

% Convert to categorical 
hemisphere_cat = categorical(hemisphere_factor, [1, 2], {'Left', 'Right'});
roi_cat = categorical(roi_factor, 1:length(roi_list), roi_list);
method_cat = categorical(method_factor, [1, 2], {'UNC', 'FSaverage'});

% Use anovan
[p_values, tbl, stats] = anovan(dice_values, {hemisphere_cat, roi_cat, method_cat}, ...
    'model', 'full', ...
    'varnames', {'Hemisphere', 'ROI', 'Method'}, ...
    'display', 'on');

%% Colors for plot
color = [179 234 252; 
    154 189 249; 
    84 138 249; 
    46 92 217; 
    177 223 133; 
    102 195 162; 
    67 150 157;
    38 92 103;
    250 224 75;
    241 160 57;
    197 128 56;
    143 95 34;
    243 177 231; 
    234 51 148;
    144 31 90]/255; 
%% Create separate plots for each hemisphere

figure;
set(gcf, 'color', 'white', 'Position', [100, 100, 1500, 600]);

x = 1:length(roi_list);
y = [DC_UNC_mean_lh', DC_coarse_mean_lh'];
err = [DC_UNC_sem_lh', DC_coarse_sem_lh'];

hbar = bar(x, y, 'grouped');
hbar(1).FaceColor = 'flat';  
hbar(2).FaceColor = 'flat';  
hbar(1).CData = color + (1-color) * 0.5;      
hbar(2).CData = color; 

hold on;
hatchfill2(hbar(1), 'HatchStyle', 'single', 'HatchAngle', -45, ...
           'HatchDensity', 40, 'HatchColor', [0 0 0], 'HatchLineWidth', 1);

% Add error bars and data points 
ngroups = size(y, 1);
nbars = size(y, 2);
groupwidth = min(0.8, nbars/(nbars + 1.5));

% Store x positions for significance stars
x_positions = zeros(2, length(roi_list));
y_max_values = zeros(1, length(roi_list));

for i = 1:nbars
    x_pos = (1:ngroups) - groupwidth/2 + (2*i-1) * groupwidth / (2*nbars);
    x_positions(i, :) = x_pos;
    errorbar(x_pos, y(:, i), err(:, i), '.k');
    
    for r = 1:length(roi_list)
        if i == 1
            data_points = D_UNC_lh(r,:);
        else
            data_points = D_coarse_lh(r,:);
        end
        data_points = data_points(~isnan(data_points));
        if ~isempty(data_points)
            x_jitter = x_pos(r) + 0.05 * (rand(size(data_points)) - 0.5);
            scatter(x_jitter, data_points, 25, [0.5 0.5 0.5], 'filled', 'MarkerFaceAlpha', 0.7);
        end
    end
end

% Calculate maximum y values for each ROI 
for r = 1:length(roi_list)
    y_max_values(r) = max([y(r,:) + err(r,:)]);
end

set(gca, 'XTick', 1:length(roi_list), 'XTickLabel', roi_list);
xtickangle(45);
ylabel('Dice Coefficient');
title('lh');
ylim([0 1]);
box off;
set(gca, 'TickDir', 'out');

%% Right hemisphere plot
figure;
set(gcf, 'color', 'white', 'Position', [200, 200, 1500, 600]);

y = [DC_UNC_mean_rh', DC_coarse_mean_rh'];
err = [DC_UNC_sem_rh', DC_coarse_sem_rh'];

hbar = bar(x, y, 'grouped');
hbar(1).FaceColor = 'flat';  
hbar(2).FaceColor = 'flat';  
hbar(1).CData = color + (1-color) * 0.5;      
hbar(2).CData = color; 
ylim([0 1])
hold on;

hatchfill2(hbar(1), 'HatchStyle', 'single', 'HatchAngle', -45, ...
           'HatchDensity', 40, 'HatchColor', [0 0 0], 'HatchLineWidth', 1);

% Reset variables for right hemisphere
x_positions = zeros(2, length(roi_list));
y_max_values = zeros(1, length(roi_list));

for i = 1:nbars
    x_pos = (1:ngroups) - groupwidth/2 + (2*i-1) * groupwidth / (2*nbars);
    x_positions(i, :) = x_pos;
    errorbar(x_pos, y(:, i), err(:, i), '.k');
    
    for r = 1:length(roi_list)
        if i == 1
            data_points = D_UNC_rh(r,:);
        else
            data_points = D_coarse_rh(r,:);
        end
        data_points = data_points(~isnan(data_points));
        if ~isempty(data_points)
            x_jitter = x_pos(r) + 0.05 * (rand(size(data_points)) - 0.5);
            scatter(x_jitter, data_points, 25, [0.5 0.5 0.5], 'filled', 'MarkerFaceAlpha', 0.7);
        end
    end
end

set(gca, 'XTick', 1:length(roi_list), 'XTickLabel', roi_list);
xtickangle(45);
ylabel('Dice Coefficient');
title('rh');
ylim([0 1]);
box off;
set(gca, 'TickDir', 'out');
